# Handler消息传递机制

参考：https://blog.csdn.net/carson_ho/article/details/80305411

## 1.Handler 机制简介

- 定义
  一套 `Android` 消息传递机制 / 异步通信机制
- 作用

在多线程的应用场景中，**将工作线程中需更新`UI`的操作信息 传递到 `UI`主线程**，从而实现 工作线程对`UI`的更新处理，最终实现异步消息的处理
![示意图](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS00YTY0MDM4NjMyYzRjODhmLnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMTI0MA)

- 为什么要用 `Handler`消息传递机制
  答：**多个线程并发更新UI的同时 保证线程安全**。具体描述如下

![示意图](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS03NDc5YjRhOGI4ZmU0OGJmLnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMTI0MA)

- 总结
  使用`Handler`的原因：将工作线程需操作`UI`的消息 传递 到主线程，使得主线程可根据工作线程的需求 更新`UI`，**从而避免线程操作不安全的问题**

## 2.相关概念

关于 `Handler` 机制中的相关概念如下：

![示意图](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1kMDg5MDMwODdjYjU3NWQ5LnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMTI0MA)

## 3.使用方式

- `Handler`使用方式 因**发送消息到消息队列的方式不同而不同**

- 共分为2种：使用`Handler.sendMessage（）`、使用`Handler.post（）`

## 4.使用步骤

<font size=4>**方式1：使用 Handler.sendMessage()**</font>

在该使用方式中，又分为2种：新建`Handler`子类（内部类）、匿名 `Handler`子类

> 但本质相同，即 继承了`Handler`类 & 创建了子类

```java
/** 
  * 方式1：新建Handler子类（内部类）
  */

    // 步骤1：自定义Handler子类（继承Handler类） & 复写handleMessage（）方法
    class mHandler extends Handler {

        // 通过复写handlerMessage() 从而确定更新UI的操作
        @Override
        public void handleMessage(Message msg) {
         ...// 需执行的UI操作
            
        }
    }

    // 步骤2：在主线程中创建Handler实例
        private Handler mhandler = new mHandler();

    // 步骤3：创建所需的消息对象
        Message msg = Message.obtain(); // 实例化消息对象
        msg.what = 1; // 消息标识
        msg.obj = "AA"; // 消息内容存放

    // 步骤4：在工作线程中 通过Handler发送消息到消息队列中
    // 可通过sendMessage（） / post（）
    // 多线程可采用AsyncTask、继承Thread类、实现Runnable
        mHandler.sendMessage(msg);

    // 步骤5：开启工作线程（同时启动了Handler）
    // 多线程可采用AsyncTask、继承Thread类、实现Runnable


/** 
  * 方式2：匿名内部类
  */
   // 步骤1：在主线程中 通过匿名内部类 创建Handler类对象
            private Handler mhandler = new  Handler(){
                // 通过复写handlerMessage()从而确定更新UI的操作
                @Override
                public void handleMessage(Message msg) {
                        ...// 需执行的UI操作
                    }
            };

  // 步骤2：创建消息对象
    Message msg = Message.obtain(); // 实例化消息对象
  msg.what = 1; // 消息标识
  msg.obj = "AA"; // 消息内容存放
  
  // 步骤3：在工作线程中 通过Handler发送消息到消息队列中
  // 多线程可采用AsyncTask、继承Thread类、实现Runnable
   mHandler.sendMessage(msg);

  // 步骤4：开启工作线程（同时启动了Handler）
  // 多线程可采用AsyncTask、继承Thread类、实现Runnable

```

<font size=4>**方式2：使用 Handler.post()**</font>

```java
// 步骤1：在主线程中创建Handler实例
    private Handler mhandler = new mHandler();

    // 步骤2：在工作线程中 发送消息到消息队列中 & 指定操作UI内容
    // 需传入1个Runnable对象
    mHandler.post(new Runnable() {
            @Override
            public void run() {
                ... // 需执行的UI操作 
            }

    });

    // 步骤3：开启工作线程（同时启动了Handler）
    // 多线程可采用AsyncTask、继承Thread类、实现Runnable
```

